// Package fsmgr manages fs objects
package fsmgr

import (
	"bytes"
	"compress/zlib"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"github.com/manx98/local_to_seaf_store/objstore"
	"io"
	"syscall"
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary

var store *objstore.ObjectStore

func Init(dataDir string) {
	store = objstore.New(dataDir, "fs")
}

// Seafile is a file object
type Seafile struct {
	data     []byte
	Version  int      `json:"version"`
	FileType int      `json:"type"`
	FileID   string   `json:"-"`
	FileSize uint64   `json:"size"`
	BlkIDs   []string `json:"block_ids"`
}

// In the JSON encoding generated by C language, there are spaces after the ',' and ':', and the order of the fields is sorted by the key.
// So it is not compatible with the json library generated by go.
func (f *Seafile) toJSON() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteByte('{')
	buf.WriteString("\"block_ids\": [")
	for i, blkID := range f.BlkIDs {
		data, err := json.Marshal(blkID)
		if err != nil {
			return nil, err
		}
		buf.Write(data)
		if i < len(f.BlkIDs)-1 {
			buf.WriteByte(',')
			buf.WriteByte(' ')
		}
	}
	buf.WriteByte(']')
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err := json.Marshal(f.FileSize)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"size\"", data)
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err = json.Marshal(SeafMetadataTypeFile)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"type\"", data)
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err = json.Marshal(f.Version)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"version\"", data)

	buf.WriteByte('}')

	return buf.Bytes(), nil
}

func writeField(buf *bytes.Buffer, key string, value []byte) {
	buf.WriteString(key)
	buf.WriteByte(':')
	buf.WriteByte(' ')
	buf.Write(value)
}

// SeafDirent is a dir entry object
type SeafDirent struct {
	Mode     uint32 `json:"mode"`
	ID       string `json:"id"`
	Name     string `json:"name"`
	Mtime    int64  `json:"mtime"`
	Modifier string `json:"modifier"`
	Size     int64  `json:"size"`
}

func (dent *SeafDirent) toJSON() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteByte('{')
	data, err := json.Marshal(dent.ID)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"id\"", data)
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err = json.Marshal(dent.Mode)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"mode\"", data)
	buf.WriteByte(',')
	buf.WriteByte(' ')

	if IsRegular(dent.Mode) {
		data, err = jsonNoEscape(dent.Modifier)
		if err != nil {
			return nil, err
		}
		writeField(&buf, "\"modifier\"", data)
		buf.WriteByte(',')
		buf.WriteByte(' ')
	}

	data, err = json.Marshal(dent.Mtime)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"mtime\"", data)
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err = jsonNoEscape(dent.Name)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"name\"", data)

	if IsRegular(dent.Mode) {
		buf.WriteByte(',')
		buf.WriteByte(' ')
		data, err = json.Marshal(dent.Size)
		if err != nil {
			return nil, err
		}
		writeField(&buf, "\"size\"", data)
	}
	buf.WriteByte('}')

	return buf.Bytes(), nil
}

// In golang json, the string is encoded using HTMLEscape, which replaces "<", ">", "&", U+2028, and U+2029 are escaped to "\u003c","\u003e", "\u0026", "\u2028", and "\u2029".
// So it is not compatible with the json library generated by c. This replacement can be disabled when using an Encoder, by calling SetEscapeHTML(false).
func jsonNoEscape(data interface{}) ([]byte, error) {
	var buf bytes.Buffer

	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false)

	if err := encoder.Encode(data); err != nil {
		return nil, err
	}

	bytes := buf.Bytes()

	// Encode will terminate each value with a newline.
	// This makes the output look a little nicer
	// when debugging, and some kind of space
	// is required if the encoded value was a number,
	// so that the reader knows there aren't more
	// digits coming.
	// The newline at the end needs to be removed for the above reasons.
	return bytes[:len(bytes)-1], nil
}

// SeafDir is a dir object
type SeafDir struct {
	data    []byte
	Version int           `json:"version"`
	DirType int           `json:"type"`
	DirID   string        `json:"-"`
	Entries []*SeafDirent `json:"dirents"`
}

func (d *SeafDir) toJSON() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteByte('{')
	buf.WriteString("\"dirents\": [")
	for i, entry := range d.Entries {
		data, err := entry.toJSON()
		if err != nil {
			return nil, err
		}
		buf.Write(data)
		if i < len(d.Entries)-1 {
			buf.WriteByte(',')
			buf.WriteByte(' ')
		}
	}
	buf.WriteByte(']')
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err := json.Marshal(SeafMetadataTypeDir)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"type\"", data)
	buf.WriteByte(',')
	buf.WriteByte(' ')

	data, err = json.Marshal(d.Version)
	if err != nil {
		return nil, err
	}
	writeField(&buf, "\"version\"", data)

	buf.WriteByte('}')

	return buf.Bytes(), nil
}

// Meta data type of dir or file
const (
	SeafMetadataTypeInvalid = iota
	SeafMetadataTypeFile
	SeafMetadataTypeLink
	SeafMetadataTypeDir
)

// Empty value of sha1
const (
	EmptySha1 = "0000000000000000000000000000000000000000"
)

// NewDirent initializes a SeafDirent object
func NewDirent(id string, name string, mode uint32, mtime int64, modifier string, size int64) *SeafDirent {
	dent := new(SeafDirent)
	dent.ID = id
	if id == "" {
		dent.ID = EmptySha1
	}
	dent.Name = name
	dent.Mode = mode
	dent.Mtime = mtime
	if IsRegular(mode) {
		dent.Modifier = modifier
		dent.Size = size
	}

	return dent
}

// NewSeafdir initializes a SeafDir object
func NewSeafdir(version int, entries []*SeafDirent) (*SeafDir, error) {
	dir := new(SeafDir)
	dir.Version = version
	dir.Entries = entries
	if len(entries) == 0 {
		dir.DirID = EmptySha1
		return dir, nil
	}
	jsonstr, err := dir.toJSON()
	if err != nil {
		return nil, fmt.Errorf("convert seafdir to json: %w", err)
	}
	dir.data = jsonstr
	checksum := sha1.Sum(jsonstr)
	dir.DirID = hex.EncodeToString(checksum[:])

	return dir, nil
}

// NewSeafile initializes a Seafile object
func NewSeafile(version int, fileSize int64, blkIDs []string) (*Seafile, error) {
	seafile := new(Seafile)
	seafile.Version = version
	seafile.FileSize = uint64(fileSize)
	seafile.BlkIDs = blkIDs
	if len(blkIDs) == 0 {
		seafile.FileID = EmptySha1
		return seafile, nil
	}

	jsonstr, err := seafile.toJSON()
	if err != nil {
		err := fmt.Errorf("failed to convert seafile to json")
		return nil, err
	}
	seafile.data = jsonstr
	checkSum := sha1.Sum(jsonstr)
	seafile.FileID = hex.EncodeToString(checkSum[:])

	return seafile, nil
}

func compress(p []byte) ([]byte, error) {
	var out bytes.Buffer
	w := zlib.NewWriter(&out)

	_, err := w.Write(p)
	if err != nil {
		w.Close()
		return nil, err
	}

	w.Close()

	return out.Bytes(), nil
}

// ToData converts seafile to JSON-encoded data and writes to w.
func (f *Seafile) ToData(w io.Writer) error {
	buf, err := compress(f.data)
	if err != nil {
		return err
	}

	_, err = w.Write(buf)
	if err != nil {
		return err
	}

	return nil
}

// ToData converts seafdir to JSON-encoded data and writes to w.
func (d *SeafDir) ToData(w io.Writer) error {
	buf, err := compress(d.data)
	if err != nil {
		return err
	}

	_, err = w.Write(buf)
	if err != nil {
		return err
	}

	return nil
}

// WriteRaw writes data in binary format to storage backend.
func WriteRaw(repoID string, objID string, r io.Reader) error {
	err := store.Write(repoID, objID, r, false)
	if err != nil {
		return err
	}
	return nil
}

// SaveSeafile saves seafile to storage backend.
func SaveSeafile(repoID string, seafile *Seafile) error {
	fileID := seafile.FileID
	if fileID == EmptySha1 {
		return nil
	}

	exist, _ := store.Exists(repoID, fileID)
	if exist {
		return nil
	}

	seafile.FileType = SeafMetadataTypeFile
	var buf bytes.Buffer
	err := seafile.ToData(&buf)
	if err != nil {
		errors := fmt.Errorf("failed to convert seafile object %s/%s to json", repoID, fileID)
		return errors
	}

	err = WriteRaw(repoID, fileID, &buf)
	if err != nil {
		errors := fmt.Errorf("failed to write seafile object to storage : %v", err)
		return errors
	}

	return nil
}

// SaveSeafdir saves seafdir to storage backend.
func SaveSeafdir(repoID string, seafdir *SeafDir) error {
	dirID := seafdir.DirID
	if dirID == EmptySha1 {
		return nil
	}
	exist, _ := store.Exists(repoID, dirID)
	if exist {
		return nil
	}

	seafdir.DirType = SeafMetadataTypeDir
	var buf bytes.Buffer
	err := seafdir.ToData(&buf)
	if err != nil {
		errors := fmt.Errorf("failed to convert seafdir object %s/%s to json", repoID, dirID)
		return errors
	}

	err = WriteRaw(repoID, dirID, &buf)
	if err != nil {
		errors := fmt.Errorf("failed to write seafdir object to storage : %v", err)
		return errors
	}

	return nil
}

// IsRegular Check if the mode is regular.
func IsRegular(m uint32) bool {
	return (m & syscall.S_IFMT) == syscall.S_IFREG
}
